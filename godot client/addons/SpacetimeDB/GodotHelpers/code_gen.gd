@tool
class_name Codegen extends Node
@export var OPTION_HANDLING = RustOptionHandling.OPTION_T_AS_T
const CODEGEN_FOLDER = "schema"

const GDNATIVE_TYPES := {
	"I8": "int",
	"I16": "int",
	"I32": "int",
	"I64": "int",
	"U8": "int",
	"U16": "int",
	"U32": "int",
	"U64": "int",
	"F32": "float",
	"F64": "float",
	"String": "String",
	"Vector4": "Vector4",
	"Vector4I": "Vector4i",
	"Vector3": "Vector3",
	"Vector3I": "Vector3i",
	"Vector2": "Vector2",
	"Vector2I": "Vector2i",
	"Plane": "Plane",
	"Color": "Color",
	"Quaternion": "Quaternion",
	"Bool": "bool",
}
var TYPE_MAP := {
	"__identity__": "PackedByteArray",
	"__timestamp_micros_since_unix_epoch__": "int",
}
var META_TYPE_MAP := {
	"I8": "i8",
	"I16": "i16",
	"I32": "i32",
	"I64": "i64",
	"U8": "u8",
	"U16": "u16",
	"U32": "u32",
	"U64": "u64",
	"F32": "f32",
	"F64": "f64",
	"__identity__": "identity",
	"__timestamp_micros_since_unix_epoch__": "i64",
}

enum RustOptionHandling {
	IGNORE = 1, #This will not generate any fields for Option<T> types.
	USE_GODOT_OPTION = 2, #https://github.com/WhoStoleMyCoffee/godot-optional/tree/main
	OPTION_T_AS_T = 3 #This will use Option<T> as T in GDScript. This may have issues with nullability in Godot, so use with caution.
}


func _enter_tree():	
	TYPE_MAP.merge(GDNATIVE_TYPES)

func _on_request_completed(json_string, module_name):
	var json = JSON.parse_string(json_string)
	var generated_code: Dictionary = parse_schema(json, module_name)
	if not DirAccess.dir_exists_absolute("res://%s" % "codegen"):
		DirAccess.make_dir_recursive_absolute("res://%s" % "codegen")
	var file = FileAccess.open("res://%s/readme.txt" % "codegen", FileAccess.WRITE)
	file.store_string("You can delete this directory and files. It's only used for codegen debugging.")
	file = FileAccess.open("res://%s/schema_%s.json" % ["codegen", module_name], FileAccess.WRITE)
	file.store_string(JSON.stringify(generated_code, "\t", false))
	build_gdscript_from_schema(generated_code)

func build_gdscript_from_schema(schema: Dictionary) -> void:
	var module_name: String = schema.get("module", null)
	var generated_files := []
	for type in schema.get("types", []):
		if type.has("gd_native"): continue
		if type.has("struct"):
			var struct: Array = type.get("struct", [])
			var folder_path: String = "spacetime_types"
			if type.has("table_name"):
				folder_path = "tables"
			var content: String = generate_struct_gdscript(type, module_name)
			var output_file_name: String = "%s_%s.gd" % \
				[module_name.to_snake_case(), type.get("name", "").to_snake_case()]
			var output_file_path: String = "res://%s/%s/%s" % [CODEGEN_FOLDER, folder_path, output_file_name]
			if not DirAccess.dir_exists_absolute("res://%s/%s" % [CODEGEN_FOLDER, folder_path]):
				DirAccess.make_dir_recursive_absolute("res://%s/%s" % [CODEGEN_FOLDER, folder_path])
			var file = FileAccess.open(output_file_path, FileAccess.WRITE)
			if file:
				file.store_string(content)
			generated_files.append(output_file_path)
			# Spacetime.print_log(["Content:", content])
		elif type.has("enum"):
			var sum: Array = type.get("enum", [])
			var folder_path: String = "spacetime_types"
			var content: String = generate_enum_gdscript(type, module_name)
			var output_file_name: String = "%s_%s.gd" % \
				[module_name.to_snake_case(), type.get("name", "").to_snake_case()]
			var output_file_path: String = "res://%s/%s/%s" % [CODEGEN_FOLDER, folder_path, output_file_name]
			if not DirAccess.dir_exists_absolute("res://%s/%s" % [CODEGEN_FOLDER, folder_path]):
				DirAccess.make_dir_recursive_absolute("res://%s/%s" % [CODEGEN_FOLDER, folder_path])
			var file = FileAccess.open(output_file_path, FileAccess.WRITE)
			if file:
				file.store_string(content)
			generated_files.append(output_file_path)
	Spacetime.print_log(["Generated files:\n", "\n".join(generated_files)])

func generate_struct_gdscript(type, module_name) -> String:
	var struct_name: String = type.get("name", "")
	var fields: Array = type.get("struct", [])
	var meta_data: Array = []
	var table_name: String = type.get("table_name", "")
	var _class_name: String = module_name.to_pascal_case() + struct_name.to_pascal_case()
	if table_name:
		meta_data.append("set_meta('table_name', '%s')" % table_name)
		var primary_key_name: String = type.get("primary_key_name", "")
		if primary_key_name:
			meta_data.append("set_meta('primary_key', '%s')" % primary_key_name)
	var content: String = "#Do not edit this file, it is generated automatically.\n" + \
	"class_name %s extends Resource\n\n" % _class_name
	var class_fields: Array = []
	for field in fields:
		var field_name: String = field.get("name", "")
		var field_type: String = TYPE_MAP.get(field.get("type", ""), "")
		if field.has("is_option"):
			match OPTION_HANDLING:
				RustOptionHandling.IGNORE: continue
				RustOptionHandling.USE_GODOT_OPTION:
					field_type = "Option"
		if field.has("is_array"):
			field_type = "Array[%s]" % field_type
		var meta: String = META_TYPE_MAP.get(field.get("type", ""), "")
		if not meta.is_empty():
			meta_data.append("set_meta('bsatn_type_%s', '%s')" 
				% [field_name.to_snake_case(), meta])
		content += "@export var %s: %s\n" % [field_name, field_type]
		class_fields.append([field_name, field_type])
	content += "\nfunc _init():\n"
	for m in meta_data:
		content += "\t%s\n" % m
	if meta_data.size() == 0:
		content += "\tpass\n"
	content += "\nstatic func create(%s) -> %s:\n" % \
	[", ".join(class_fields.map(func(x): return "_%s: %s" % [x[0], x[1]])), _class_name] + \
	"\tvar result = %s.new()" % [_class_name]
	for field in fields:
		var field_name: String = field.get("name", "")
		content += "\n\tresult.%s = _%s" % [field_name, field_name]
	content += "\n\treturn result\n"
	return content.left(-1)

func generate_enum_gdscript(type, module_name) -> String:
	var enum_name: String = type.get("name", "")
	var variants: Array = type.get("enum", [""])
	var default_value: String = variants[0].get("name", "")
	var variant_types: String = "["
	var variant_names: String = ""
	for v in variants:
		variant_names += "\t%s,\n" % [v.get("name", "")]
		var _type = META_TYPE_MAP.get(v.get("type", ""), "")
		if v.has("is_array"):
			variant_types += "&'vec_%s', " % _type
		elif _type.is_empty():
			variant_types += "'', "
		else:
			variant_types += "&'%s', " % _type
	variant_types = variant_types.left(-2) + "]"
	variant_names = variant_names.left(-2)
	var _class_name: String = module_name.to_pascal_case() + enum_name.to_pascal_case()
	var content: String = "#Do not edit this file, it is generated automatically.\n" + \
	"class_name %s extends Resource\n\n" % _class_name + \
	"""const enum_sub_classes: Array = %s\n""" % variant_types + \
	"var value: int = %s\n" % default_value + \
	"var data: Variant\n\n" + \
	"enum {\n%s\n}\n\n" % variant_names + \
	"static func parse(i: int) -> String:\n" + \
	"\tmatch i:\n"
	for i in range(variants.size()):
		content += "\t\t%d: return \"%s\"\n" % [i, variants[i].get("name", "")]
	content += "\t\t_:\n" + \
	"\t\t\tprinterr(\"Enum does not have value for %d. This is out of bounds.\")\n" + \
	"\t\t\treturn \"Unknown\"\n\n" + \
	"static func create(type: int, _data: Variant = null) -> %s:\n" % _class_name + \
	"\tvar result = %s.new()\n" % _class_name + \
	"\tresult.value = type\n" + \
	"\tresult.data = _data\n" + \
	"\treturn result\n\n"
	for v in variants:
		var variant_name: String = v.get("name", "")
		var variant_type: String = TYPE_MAP.get(v.get("type", ""), "")
		if variant_type.is_empty():
			content += "static func create_%s() -> %s:\n" % [variant_name.to_snake_case(), _class_name] + \
			"\treturn create(%s)\n\n" % [variant_name]
			continue
		if v.has("is_array"):
			variant_type = "Array[%s]" % variant_type
		content += "static func create_%s(_data: %s) -> %s:\n" % [variant_name.to_snake_case(), variant_type, _class_name] + \
		"\treturn create(%s, _data)\n\n" % [variant_name]
	return content.left(-2)

func parse_schema(schema: Dictionary, module_name: String) -> Dictionary:
	var schema_tables: Array = schema.get("tables", [])
	var schema_types: Array= schema.get("types", [])
	var schema_reducers: Array = schema.get("reducers", [])
	var typespace: Array = schema.get("typespace", {}).get("types", [])
	schema_types.sort_custom(func(a, b): return a.get("ty", -1) < b.get("ty", -1))
	var types := []

	for type_info in schema_types:
		var type_name: String = type_info.get("name", {}).get("name", null)
		if not type_name:
			printerr("Invalid schema: Type name not found for type: %s" % type_info)
			return {}
		var type_data := {
			"name": type_name,
		}
		if GDNATIVE_TYPES.has(type_name):
			type_data["gd_native"] = true
		var ty := int(type_info.get("ty", -1))
		if ty == -1:
			printerr("Invalid schema: Type 'ty' not found for type: %s" % type_info)
			return {}
		var struct: Dictionary = typespace[ty].get("Product", {})
		var sum_type: Dictionary = typespace[ty].get("Sum", {})
		if struct:
			var elements := []
			for e in struct.get("elements", []):
				var data := {
					"name": e.get("name",{}).get("some", null),
				}
				var field_type = e.get("algebraic_type", {})
				if field_type.has("Array"):
					data["is_array"] = true
					field_type = field_type.Array
				if field_type.has("Product"):
					field_type = field_type.Product.get("elements", [])[0].get('name', {}).get('some', null)
				elif field_type.has("Sum"):
					if is_sum_option(field_type.Sum):
						data["is_option"] = true
					field_type = field_type.Sum.variants[0].get('algebraic_type', {}).keys()[0]
				elif field_type.has("Ref"):
					field_type = schema_types[field_type.Ref].get("name", {}).get("name", null)
				else:
					field_type = field_type.keys()[0]
				data["type"] = field_type				
				elements.append(data)
			if not type_data.has("gd_native"):
				TYPE_MAP[type_name] = module_name.to_pascal_case() + type_name.to_pascal_case()
				META_TYPE_MAP[type_name] = module_name.to_pascal_case() + type_name.to_pascal_case()
			type_data["struct"] = elements
			types.append(type_data)
		elif sum_type:
			var elements := []
			for e in sum_type.get("variants", []):
				var data := {
					"name": e.get("name",{}).get("some", null),
				}
				var variant_type = e.get("algebraic_type", {})
				if variant_type.has("Array"):
					data["is_array"] = true
					variant_type = variant_type.Array
				if variant_type.has("Product"):
					variant_type = variant_type.Product.get("elements", [])
					if variant_type.size() >= 1:
						variant_type = variant_type[0].get('name', {}).get('some', null)
					else:
						variant_type = null
				elif variant_type.has("Sum"):
					if is_sum_option(variant_type.Sum):
						data["is_option"] = true
					variant_type = variant_type.Sum.variants[0].get('algebraic_type', {}).keys()[0]
				elif variant_type.has("Ref"):
					variant_type = schema_types[variant_type.Ref].get("name", {}).get("name", null)
				else:
					variant_type = variant_type.keys()[0]
				if variant_type:
					data["type"] = variant_type
				elements.append(data)
			type_data["enum"] = elements
			types.append(type_data)
			TYPE_MAP[type_name] = module_name.to_pascal_case() + type_name.to_pascal_case()
			META_TYPE_MAP[type_name] = "enum"
		else:
			printerr("Invalid schema: Type 'Product' or 'Sum' not found for type: %s" % type_info)
			return {}

	for table_info in schema_tables:
		var table_name: String = table_info.get("name", null)
		var ref = table_info.get("product_type_ref", null)
		if ref == null or table_name == null: continue
		types[ref].table_name = table_name
		var primary_key: Array = table_info.get("primary_key", [])
		if primary_key.size() == 1:
			types[ref].primary_key = int(primary_key[0])
			types[ref].primary_key_name = types[ref].struct[primary_key[0]].name
	
	var reducers := []
	for reducer_info in schema_reducers:
		var lifecycle = reducer_info.get("lifecycle", {}).get("some", null)
		if lifecycle: continue
		var name = reducer_info.get("name", null)
		var params := []
		for p in reducer_info.get("params", {}).get("elements", []):
			var data := {
				"name": p.get("name",{}).get("some", null),
			}
			var param_type = p.get("algebraic_type", {})
			if param_type.has("Array"):
				data["is_array"] = true
				param_type = param_type.Array
			if param_type.has("Product"):
				param_type = param_type.Product.get("elements", [])[0].get('name', {}).get('some', null)
			elif param_type.has("Ref"):
				param_type = schema_types[param_type.Ref].get("name", {}).get("name", null)
			elif param_type.has("Sum"):
				if is_sum_option(param_type.Sum):
					data["is_option"] = true
				param_type = param_type.Sum.variants[0].get('algebraic_type', {}).keys()[0]
			else:
				param_type = param_type.keys()[0]
			data["type"] = param_type
			params.append(data)
		reducers.append({
			"name": name,
			"params": params
		})

	var parsed_schema = {
		"module": module_name,
		"types": types,
		"reducers": reducers,
		"type_map": TYPE_MAP,
		"meta_type_map": META_TYPE_MAP,
		"tables": schema_tables,
	}
	return parsed_schema

func is_sum_option(sum) -> bool:
	var variants = sum.get("variants", [])
	if variants.size() != 2:
		return false
	elif variants[0].get("name", {}).get("some", "") != "some":
		return false
	elif variants[1].get("name", {}).get("some", "") != "none":
		return false
	return true
